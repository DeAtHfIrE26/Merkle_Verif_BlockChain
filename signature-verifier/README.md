<img width="2000rem" src="https://raw.githubusercontent.com/SamirPaulb/SamirPaulb/main/assets/rainbow-superthin.webp"><br>

<!-- Futuristic Header -->
<div align="center">
  <img width="100%" src="https://capsule-render.vercel.app/api?type=waving&color=0:3d85c6,100:00ffff&height=200&section=header&text=Task3%3A%20Signature%20Verifier&fontSize=60&fontColor=fff&animation=fadeIn&fontAlignY=38&desc=Universal+Signature+Verification+for+Blockchain&descAlignY=60&descAlign=50" />
</div>

<img width="2000rem" src="https://raw.githubusercontent.com/SamirPaulb/SamirPaulb/main/assets/rainbow-superthin.webp"><br>

# ğŸ› ï¸ Task 3: Modular Signature Scheme Verification

## ğŸ“„ Overview

The **Signature Verifier** project implements a modular algorithm designed to verify signatures generated by multiple signature schemes (e.g., **ECDSA**, **Schnorr**, **RSA**). This flexibility allows the verifier to adapt dynamically based on the provided signature scheme and ensure robust verification for a wide range of applications. By leveraging a smart contract, the solution performs on-chain verification to recover the signer address and validate the authenticity of transactions.

## ğŸŒŸ Features

- **Universal Compatibility**: Supports multiple signature schemes such as ECDSA, Schnorr, and RSA.
- **Flexible Signature Format**: Accepts signature data in `bytes` format, enabling adaptability to various formats.
- **Efficient Verification**: Optimized for gas efficiency with early exit conditions and conditional checks.
- **Address Recovery**: Retrieves the signer's address to confirm the authenticity of signatures.
- **Modular Design**: Allows for easy expansion to support additional signature schemes in the future.

## ğŸ”§ Setup Instructions

### Prerequisites

- **Node.js** (v14.x or later)
- **npm** (v6.x or later)
- **Hardhat**: Ethereum development environment
- **Infura Account**: To access Ethereum nodes
- **MetaMask**: For managing Ethereum accounts

### Step-by-Step Setup

1. **Clone the Repository**

    ```bash
    git clone https://github.com/DeAtHfIrE26/charter-21BCE0216.git
    cd charter-21BCE0216/signature-verifier
    ```

2. **Install Dependencies**

    ```bash
    npm install
    ```

3. **Configure Environment Variables**

    Create a `.env` file in the root directory with the following content:

    ```env
    INFURA_PROJECT_ID=your_infura_project_id
    PRIVATE_KEY=your_private_key
    ```

    > **Note**: Replace `your_infura_project_id` with your actual Infura project ID and `your_private_key` with the private key of the Ethereum account you are using for deployment.

4. **Compile the Smart Contract**

    ```bash
    npx hardhat compile
    ```

5. **Deploy the Smart Contract**

    Ensure you have some Sepolia ETH in your account for deployment.

    ```bash
    npx hardhat run scripts/deploy.js --network sepolia
    ```

    > **Expected Output**:
    > ```
    > Deploying contracts with the account: 0xYourDeployerAddress
    > SignatureVerifier deployed to: 0xDeployedContractAddress
    > ```

---

## ğŸ“œ Usage

### Interacting with the Contract

You can interact with the deployed `SignatureVerifier` contract by calling the `verifySignature` function directly or integrating it into other smart contracts or frontend applications.

#### Example: Verifying a Signature

```javascript
const { ethers } = require("hardhat");

async function verifySignature() {
  const [deployer] = await ethers.getSigners();
  const verifier = await ethers.getContractAt("SignatureVerifier", "0xDeployedContractAddress");

  const signerAddress = "0xSignerAddress";
  const signature = "0xSignatureBytes";
  const messageHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("Message to be signed"));
  const schemeType = 0; // 0 for ECDSA, 1 for Schnorr, 2 for RSA

  const isValid = await verifier.verifySignature(signerAddress, signature, messageHash, schemeType);
  console.log(`Is the signature valid? ${isValid}`);
}

verifySignature()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

## ğŸ§ª Testing
1. Run Unit Tests
The project includes comprehensive tests to ensure the signature verification logic works as expected.

bash
```
npx hardhat test
```
Expected Output:

```
  SignatureVerifier
    âœ“ Should verify a valid ECDSA signature (X ms)
    âœ“ Should fail verification with an invalid signature (X ms)
    âœ“ Should fail verification if the signer address does not match (X ms)
    âœ“ Should fail verification with an unsupported scheme type (X ms)

  4 passing (X seconds)
```
2. Add More Tests
Expand the test suite to include various edge cases and signature schemes:

Edge Cases: Invalid signature lengths, malformed bytes inputs, etc.
Unsupported Schemes: Ensure unsupported signature types are rejected.
High-Volume Testing: Test with multiple signatures to simulate real-world usage.

## ğŸ“‚ Project Structure

```
signature-verifier/
â”œâ”€â”€ README.md
â”œâ”€â”€ contracts/
â”‚   â””â”€â”€ SignatureVerifier.sol
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ deploy.js
â”œâ”€â”€ test/
â”‚   â””â”€â”€ SignatureVerifier.test.js
â”œâ”€â”€ hardhat.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ .env
â””â”€â”€ .gitignore
```
## ğŸ”— Related Links
Ethereum Documentation
Ethers.js Documentation
Hardhat Documentation
Infura
MetaMask
Elliptic Curve Digital Signature Algorithm (ECDSA)
Schnorr Signature
RSA Signature

## ğŸ“ Best Practices
Security Audits: Regularly audit your smart contracts for vulnerabilities.
Gas Optimization: Avoid unnecessary calculations to reduce gas costs during verification.
Comprehensive Testing: Test across all supported signature schemes to maintain reliability.
Modular Code Design: Keep functions modular to facilitate easier addition of new signature schemes.
Documentation: Provide clear, thorough documentation for ease of understanding and collaboration.
Environment Management: Use environment variables and .gitignore to protect sensitive information.
