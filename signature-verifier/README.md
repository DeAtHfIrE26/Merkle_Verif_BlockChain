<img width="2000rem" src="https://raw.githubusercontent.com/SamirPaulb/SamirPaulb/main/assets/rainbow-superthin.webp"><br>

<!-- Futuristic Header -->
<div align="center">
  <img width="100%" src="https://capsule-render.vercel.app/api?type=waving&color=0:3d85c6,100:00ffff&height=200&section=header&text=Task3%3A%20Signature%20Verifier&fontSize=60&fontColor=fff&animation=fadeIn&fontAlignY=38&desc=Universal+Signature+Verification+for+Blockchain&descAlignY=60&descAlign=50" />
</div>

<img width="2000rem" src="https://raw.githubusercontent.com/SamirPaulb/SamirPaulb/main/assets/rainbow-superthin.webp"><br>

# 🛠️ Task 3: Modular Signature Scheme Verification

## 📄 Overview

The **Signature Verifier** project implements a modular algorithm designed to verify signatures generated by multiple signature schemes (e.g., **ECDSA**, **Schnorr**, **RSA**). This flexibility allows the verifier to adapt dynamically based on the provided signature scheme and ensure robust verification for a wide range of applications. By leveraging a smart contract, the solution performs on-chain verification to recover the signer address and validate the authenticity of transactions.

## 🌟 Features

- **Universal Compatibility**: Supports multiple signature schemes such as ECDSA, Schnorr, and RSA.
- **Flexible Signature Format**: Accepts signature data in `bytes` format, enabling adaptability to various formats.
- **Efficient Verification**: Optimized for gas efficiency with early exit conditions and conditional checks.
- **Address Recovery**: Retrieves the signer's address to confirm the authenticity of signatures.
- **Modular Design**: Allows for easy expansion to support additional signature schemes in the future.

## 🔧 Setup Instructions

### Prerequisites

- **Node.js** (v14.x or later)
- **npm** (v6.x or later)
- **Hardhat**: Ethereum development environment
- **Infura Account**: To access Ethereum nodes
- **MetaMask**: For managing Ethereum accounts

### Step-by-Step Setup

1. **Clone the Repository**

    ```bash
    git clone https://github.com/DeAtHfIrE26/charter-21BCE0216.git
    cd charter-21BCE0216/signature-verifier
    ```

2. **Install Dependencies**

    ```bash
    npm install
    ```

3. **Configure Environment Variables**

    Create a `.env` file in the root directory with the following content:

    ```env
    INFURA_PROJECT_ID=your_infura_project_id
    PRIVATE_KEY=your_private_key
    ```

    > **Note**: Replace `your_infura_project_id` with your actual Infura project ID and `your_private_key` with the private key of the Ethereum account you are using for deployment.

4. **Compile the Smart Contract**

    ```bash
    npx hardhat compile
    ```

5. **Deploy the Smart Contract**

    Ensure you have some Sepolia ETH in your account for deployment.

    ```bash
    npx hardhat run scripts/deploy.js --network sepolia
    ```

    > **Expected Output**:
    > ```
    > Deploying contracts with the account: 0xYourDeployerAddress
    > SignatureVerifier deployed to: 0xDeployedContractAddress
    > ```

---

## 📜 Usage

### Interacting with the Contract

You can interact with the deployed `SignatureVerifier` contract by calling the `verifySignature` function directly or integrating it into other smart contracts or frontend applications.

#### Example: Verifying a Signature

```javascript
const { ethers } = require("hardhat");

async function verifySignature() {
  const [deployer] = await ethers.getSigners();
  const verifier = await ethers.getContractAt("SignatureVerifier", "0xDeployedContractAddress");

  const signerAddress = "0xSignerAddress";
  const signature = "0xSignatureBytes";
  const messageHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("Message to be signed"));
  const schemeType = 0; // 0 for ECDSA, 1 for Schnorr, 2 for RSA

  const isValid = await verifier.verifySignature(signerAddress, signature, messageHash, schemeType);
  console.log(`Is the signature valid? ${isValid}`);
}

verifySignature()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

## 🧪 Testing
1. Run Unit Tests
The project includes comprehensive tests to ensure the signature verification logic works as expected.

bash
```
npx hardhat test
```
Expected Output:

```
  SignatureVerifier
    ✓ Should verify a valid ECDSA signature (X ms)
    ✓ Should fail verification with an invalid signature (X ms)
    ✓ Should fail verification if the signer address does not match (X ms)
    ✓ Should fail verification with an unsupported scheme type (X ms)

  4 passing (X seconds)
```
2. Add More Tests
Expand the test suite to include various edge cases and signature schemes:

Edge Cases: Invalid signature lengths, malformed bytes inputs, etc.
Unsupported Schemes: Ensure unsupported signature types are rejected.
High-Volume Testing: Test with multiple signatures to simulate real-world usage.

## 📂 Project Structure

```
signature-verifier/
├── README.md
├── contracts/
│   └── SignatureVerifier.sol
├── scripts/
│   └── deploy.js
├── test/
│   └── SignatureVerifier.test.js
├── hardhat.config.js
├── package.json
├── .env
└── .gitignore
```
## 🔗 Related Links
Ethereum Documentation
Ethers.js Documentation
Hardhat Documentation
Infura
MetaMask
Elliptic Curve Digital Signature Algorithm (ECDSA)
Schnorr Signature
RSA Signature

## 📝 Best Practices
Security Audits: Regularly audit your smart contracts for vulnerabilities.
Gas Optimization: Avoid unnecessary calculations to reduce gas costs during verification.
Comprehensive Testing: Test across all supported signature schemes to maintain reliability.
Modular Code Design: Keep functions modular to facilitate easier addition of new signature schemes.
Documentation: Provide clear, thorough documentation for ease of understanding and collaboration.
Environment Management: Use environment variables and .gitignore to protect sensitive information.
